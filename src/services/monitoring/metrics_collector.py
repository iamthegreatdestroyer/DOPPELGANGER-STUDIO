"""\nMetrics Collector - Collects performance metrics for monitoring.\n\nProvides comprehensive metrics collection for script generation pipeline\nwith support for custom metrics, aggregation, and export.\n\nCopyright (c) 2025. All Rights Reserved. Patent Pending.\n\"""\n\nimport logging\nimport time\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom collections import defaultdict\nimport statistics\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass MetricPoint:\n    \"\"\"Single metric measurement.\"\"\"\n    name: str\n    value: float\n    timestamp: datetime\n    tags: Dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass AggregatedMetric:\n    \"\"\"Aggregated metric statistics.\"\"\"\n    name: str\n    count: int\n    sum: float\n    min: float\n    max: float\n    mean: float\n    median: float\n    p95: float\n    p99: float\n\n\nclass MetricsCollector:\n    \"\"\"\n    Collects and aggregates performance metrics.\n    \n    Features:\n    - Custom metric recording\n    - Automatic aggregation\n    - Percentile calculations\n    - Tag-based filtering\n    - Time-series tracking\n    \"\"\"\n    \n    def __init__(self, buffer_size: int = 10000):\n        self.buffer_size = buffer_size\n        self._metrics: Dict[str, List[MetricPoint]] = defaultdict(list)\n        self._timers: Dict[str, float] = {}\n        \n        logger.info(f\"MetricsCollector initialized (buffer={buffer_size})\")\n    \n    def record(\n        self,\n        name: str,\n        value: float,\n        tags: Optional[Dict[str, str]] = None\n    ):\n        \"\"\"Record a metric value.\"\"\"\n        point = MetricPoint(\n            name=name,\n            value=value,\n            timestamp=datetime.now(),\n            tags=tags or {}\n        )\n        \n        self._metrics[name].append(point)\n        \n        # Limit buffer size\n        if len(self._metrics[name]) > self.buffer_size:\n            self._metrics[name] = self._metrics[name][-self.buffer_size:]\n    \n    def start_timer(self, name: str):\n        \"\"\"Start a timing measurement.\"\"\"\n        self._timers[name] = time.time()\n    \n    def stop_timer(self, name: str, tags: Optional[Dict[str, str]] = None):\n        \"\"\"Stop timer and record duration.\"\"\"\n        if name in self._timers:\n            duration = time.time() - self._timers[name]\n            self.record(f\"{name}.duration\", duration, tags)\n            del self._timers[name]\n            return duration\n        return None\n    \n    def get_aggregated(self, name: str) -> Optional[AggregatedMetric]:\n        \"\"\"Get aggregated statistics for a metric.\"\"\"\n        if name not in self._metrics or not self._metrics[name]:\n            return None\n        \n        values = [p.value for p in self._metrics[name]]\n        \n        return AggregatedMetric(\n            name=name,\n            count=len(values),\n            sum=sum(values),\n            min=min(values),\n            max=max(values),\n            mean=statistics.mean(values),\n            median=statistics.median(values),\n            p95=self._percentile(values, 0.95),\n            p99=self._percentile(values, 0.99)\n        )\n    \n    def _percentile(self, values: List[float], p: float) -> float:\n        \"\"\"Calculate percentile.\"\"\"\n        if not values:\n            return 0.0\n        sorted_values = sorted(values)\n        index = int(len(sorted_values) * p)\n        return sorted_values[min(index, len(sorted_values) - 1)]\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of all metrics.\"\"\"\n        summary = {}\n        for name in self._metrics:\n            agg = self.get_aggregated(name)\n            if agg:\n                summary[name] = {\n                    'count': agg.count,\n                    'mean': agg.mean,\n                    'p95': agg.p95,\n                    'p99': agg.p99\n                }\n        return summary\n    \n    def clear(self):\n        \"\"\"Clear all metrics.\"\"\"\n        self._metrics.clear()\n        self._timers.clear()\n\n\n# Global instance\n_collector = None\n\ndef get_metrics_collector() -> MetricsCollector:\n    global _collector\n    if _collector is None:\n        _collector = MetricsCollector()\n    return _collector\n